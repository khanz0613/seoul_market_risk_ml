# 🔍 서울 시장 위험도 ML 시스템 - 실제 코드로 이해하기

> "코드가 어떻게 실제로 동작하는지 궁금하시다구요? 단계별로 보여드릴게요!"

---

## 🎯 **메인 엔트리 포인트** - 모든 것의 시작

### 📁 `src/risk_scoring/risk_calculator.py` (메인 엔진)
```python
class RiskCalculator:
    def __init__(self, config):
        """시스템 초기화 - 모든 컴포넌트 준비"""
        # 1. 설정 로딩
        self.config = config
        
        # 2. 핵심 컴포넌트들 초기화
        self.feature_engine = SeoulFeatureEngine(config)          # 특성 추출기
        self.model_orchestrator = SeoulModelOrchestrator(config)  # 모델 선택기  
        self.changepoint_detector = ChangePointDetector(config)   # 변화 탐지기
        self.loan_calculator = LoanCalculator(config)             # 대출 계산기
        
    def calculate_comprehensive_risk(self, business_data):
        """🎯 메인 함수 - 전체 플로우 실행"""
        
        # 1단계: 특성 추출
        features = self.feature_engine.extract_features(business_data)
        
        # 2단계: AI 매출 예측
        prediction = self.model_orchestrator.predict(business_data)
        
        # 3단계: 변화점 탐지
        changepoint_risk = self.changepoint_detector.detect(business_data)
        
        # 4단계: 5요소 위험도 계산
        risk_score = self._calculate_risk_components(features, changepoint_risk)
        
        # 5단계: 대출 한도 계산
        loan_amount = self.loan_calculator.calculate_limit(
            business_data, risk_score, prediction
        )
        
        # 6단계: 결과 리턴
        return {
            'risk_score': risk_score,
            'risk_level': self._get_risk_level(risk_score),
            'predicted_revenue': prediction['amount'],
            'recommended_loan': loan_amount,
            'explanation': self._generate_explanation(features, risk_score)
        }
```

**💭 이 코드가 하는 일**: 
- 사용자가 `calculate_comprehensive_risk()` 호출 하나만 하면
- 내부에서 6단계가 자동으로 실행되어 최종 결과 리턴

---

## 🤖 **스마트 모델 선택기** - AI의 두뇌

### 📁 `src/models/model_orchestrator.py` (핵심 알고리즘)
```python
class SeoulModelOrchestrator:
    def predict(self, business_data):
        """🧠 똑똑한 모델 선택 - 3단계 폴백"""
        
        region_id = business_data.get('region_id')
        business_type = business_data.get('business_type')
        
        # 1차 시도: Local 모델 (가장 정확)
        try:
            local_prediction = self._try_local_model(region_id, business_data)
            if self._is_confident_enough(local_prediction, confidence_level=0.9):
                logger.info(f"✅ Local 모델 사용: {region_id}")
                return local_prediction
        except InsufficientDataError:
            logger.info(f"⚠️ Local 모델 데이터 부족: {region_id}")
            
        # 2차 시도: Regional 모델 (중간 정확도)  
        try:
            regional_prediction = self._try_regional_model(region_id, business_data)
            if self._is_confident_enough(regional_prediction, confidence_level=0.7):
                logger.info(f"✅ Regional 모델 사용: cluster_{self._get_cluster(region_id)}")
                return regional_prediction
        except ModelNotAvailableError:
            logger.info(f"⚠️ Regional 모델 없음: {region_id}")
            
        # 3차 시도: Global 모델 (항상 사용 가능)
        global_prediction = self._try_global_model(business_data)
        logger.info("✅ Global 모델 사용 (최후 보루)")
        return global_prediction
        
    def _try_local_model(self, region_id, business_data):
        """동별 특화 모델 시도"""
        model = self.local_manager.get_model(region_id)
        if model is None:
            raise ModelNotAvailableError("Local model not available")
            
        # 데이터 충분성 검사
        if not self._has_sufficient_data(business_data, min_samples=30):
            raise InsufficientDataError("Not enough data for local model")
            
        # 예측 실행
        prediction = model.predict(business_data)
        prediction['model_level'] = 'local'
        prediction['confidence'] = self._calculate_confidence(prediction)
        
        return prediction
```

**💭 이 코드가 하는 일**:
- "홍대 치킨집" → Local 모델 있나? → 데이터 충분한가? → 신뢰도 높나?
- 문제 있으면 자동으로 Regional 모델로 시도
- 그것도 안되면 Global 모델 사용 (항상 보장)

---

## ⚗️ **특성 추출기** - 데이터를 AI가 이해할 수 있게

### 📁 `src/feature_engineering/feature_engine.py`
```python
class SeoulFeatureEngine:
    def extract_features(self, business_data):
        """🔍 중요한 특성들을 계산"""
        
        revenue_history = business_data.get('revenue_history', [])
        
        # 1. 매출 변화율 (가장 중요 - 30% 가중치)
        revenue_change = self._calculate_revenue_change(revenue_history)
        
        # 2. 변동성 (안정성 측정 - 20% 가중치)
        volatility = self._calculate_volatility(revenue_history)
        
        # 3. 트렌드 (방향성 - 20% 가중치)
        trend = self._calculate_trend(revenue_history)
        
        # 4. 계절성 (패턴 - 15% 가중치)
        seasonal_score = self._calculate_seasonality(revenue_history)
        
        # 5. 업종 비교 (상대적 성과 - 15% 가중치)
        industry_score = self._compare_with_industry(business_data)
        
        return {
            'revenue_change': revenue_change,      # 예: +9.2% 
            'volatility': volatility,              # 예: 8.5%
            'trend': trend,                        # 예: +275000원/월
            'seasonal_score': seasonal_score,       # 예: 0.85
            'industry_score': industry_score        # 예: 1.12 (업종 평균의 112%)
        }
    
    def _calculate_revenue_change(self, revenue_history):
        """매출 변화율 계산 - 가장 중요한 지표"""
        if len(revenue_history) < 2:
            return 0.0
            
        # 최근 3개월 평균 vs 이전 3개월 평균
        recent_avg = np.mean(revenue_history[-3:])
        previous_avg = np.mean(revenue_history[-6:-3])
        
        if previous_avg == 0:
            return 0.0
            
        change = (recent_avg - previous_avg) / previous_avg * 100
        return round(change, 2)
    
    def _calculate_volatility(self, revenue_history):
        """변동성 계산 - 안정성 측정"""
        if len(revenue_history) < 3:
            return 0.0
            
        # 표준편차를 평균으로 나눈 변동계수
        std = np.std(revenue_history)
        mean = np.mean(revenue_history)
        
        volatility = (std / mean) * 100 if mean > 0 else 0
        return round(volatility, 2)
```

**💭 이 코드가 하는 일**:
- 매출 숫자들 → AI가 이해할 수 있는 의미 있는 특성으로 변환
- "12M, 13.5M, 11.8M, 14.2M, 13.1M" → "변화율 +9.2%, 변동성 8.5%"

---

## ⚠️ **위험도 계산** - 은행 심사역의 두뇌

### 📁 `src/risk_scoring/risk_calculator.py` (위험도 계산 로직)
```python
def _calculate_risk_components(self, features, changepoint_risk):
    """🎯 Altman Z-Score 방식으로 5개 요소 종합"""
    
    # 설정에서 가중치 로드
    weights = self.config['risk_scoring']['weights']
    
    # 각 요소별 위험도 점수 계산
    components = {
        'revenue_change': self._score_revenue_change(features['revenue_change']),
        'volatility': self._score_volatility(features['volatility']), 
        'trend': self._score_trend(features['trend']),
        'seasonal': self._score_seasonal(features['seasonal_score']),
        'industry': self._score_industry(features['industry_score'])
    }
    
    # 가중 평균으로 총점 계산
    total_score = (
        components['revenue_change'] * weights['revenue_change'] +      # × 30%
        components['volatility'] * weights['volatility'] +              # × 20%  
        components['trend'] * weights['trend'] +                        # × 20%
        components['seasonal'] * weights['seasonal_deviation'] +        # × 15%
        components['industry'] * weights['industry_comparison']         # × 15%
    )
    
    # 변화점 탐지 결과 반영
    total_score += changepoint_risk
    
    # 0-100 범위로 제한
    total_score = max(0, min(100, total_score))
    
    return {
        'total_score': round(total_score, 1),
        'components': components,
        'weights': weights
    }

def _score_revenue_change(self, revenue_change):
    """매출 변화율을 위험도 점수로 변환"""
    # 매출 증가 = 위험 감소, 매출 감소 = 위험 증가
    if revenue_change >= 20:    # 20% 이상 증가
        return 10  # 낮은 위험
    elif revenue_change >= 10:  # 10-20% 증가
        return 20
    elif revenue_change >= 0:   # 0-10% 증가  
        return 30
    elif revenue_change >= -10: # 0-10% 감소
        return 50
    elif revenue_change >= -20: # 10-20% 감소
        return 70
    else:                       # 20% 이상 감소
        return 90  # 높은 위험
```

**💭 이 코드가 하는 일**:
- 각 특성을 0-100 점수로 변환 (높을수록 위험)
- 가중치 적용해서 최종 점수 계산
- "매출 +9.2%" → 20점, "변동성 8.5%" → 25점 등등

---

## 💰 **대출 한도 계산** - 실제 돈 결정

### 📁 `src/loan_calculation/loan_calculator.py`
```python
class LoanCalculator:
    def calculate_limit(self, business_data, risk_score, prediction):
        """💰 위험도 기반 대출 한도 계산"""
        
        # 1. 기본 한도 계산 (업종별 배수)
        base_limit = self._calculate_base_limit(business_data)
        
        # 2. 위험도에 따른 조정
        risk_adjustment = self._get_risk_adjustment(risk_score)
        
        # 3. 예측 성과에 따른 조정
        performance_adjustment = self._get_performance_adjustment(prediction)
        
        # 4. 최종 한도 계산
        final_limit = base_limit * risk_adjustment * performance_adjustment
        
        # 5. 최대/최소 한도 적용
        final_limit = self._apply_limits(final_limit, business_data)
        
        return int(final_limit)
    
    def _calculate_base_limit(self, business_data):
        """업종별 기본 대출 배수 적용"""
        revenue_history = business_data.get('revenue_history', [])
        business_type = business_data.get('business_type', 'default')
        
        # 평균 매출 계산
        avg_revenue = np.mean(revenue_history) if revenue_history else 0
        
        # 업종별 배수 (설정에서 로드)
        multipliers = self.config['loan_calculation']['business_multipliers']
        multiplier = multipliers.get(business_type, multipliers['default'])
        
        base_limit = avg_revenue * multiplier
        
        logger.info(f"기본 한도 계산: {avg_revenue:,}원 × {multiplier} = {base_limit:,}원")
        return base_limit
    
    def _get_risk_adjustment(self, risk_score):
        """위험도에 따른 한도 조정"""
        # 위험도가 높을수록 한도 감소
        if risk_score <= 20:        # 안전
            return 1.0              # 감소 없음
        elif risk_score <= 40:      # 주의  
            return 0.85             # 15% 감소
        elif risk_score <= 60:      # 경계
            return 0.7              # 30% 감소
        elif risk_score <= 80:      # 위험
            return 0.5              # 50% 감소
        else:                       # 매우위험
            return 0.3              # 70% 감소
```

**💭 이 코드가 하는 일**:
- 평균매출 1288만원 × 음식점배수 2.5 = 기본한도 3220만원
- 위험도 31.7점 → 15% 감소 적용 
- 최종 대출한도: 3220만원 × 0.85 = 2737만원

---

## 📊 **실제 실행 흐름 추적**

### 🔍 실제 로그 출력 예시
```python
# python quick_demo.py 실행시 내부 로그

INFO:src.risk_scoring.risk_calculator:🔍 특성 추출 시작: 홍대맛집
INFO:src.feature_engineering.feature_engine:매출 변화율: +9.2%
INFO:src.feature_engineering.feature_engine:변동성: 8.5%
INFO:src.feature_engineering.feature_engine:트렌드: +275000원/월

INFO:src.models.model_orchestrator:🤖 모델 선택 시작
INFO:src.models.model_orchestrator:⚠️ Local 모델 데이터 부족: 11170520
INFO:src.models.model_orchestrator:✅ Regional 모델 사용: cluster_3
INFO:src.models.regional_model:앙상블 예측 완료: 13,850,000원

INFO:src.risk_scoring.changepoint_detection:변화점 분석 완료: 변화점 없음
INFO:src.risk_scoring.risk_calculator:🎯 위험도 계산 완료: 31.7점
INFO:src.loan_calculation.loan_calculator:💰 대출 한도 계산: 27,370,000원

INFO:src.risk_scoring.risk_calculator:✅ 종합 분석 완료 (0.8초)
```

**💭 로그를 보면**:
- 각 단계별로 무슨 일이 일어나는지 실시간 확인 가능
- 어떤 모델을 선택했는지, 왜 그런 결정을 했는지 투명하게 공개

---

## 🎯 **핵심 코드 패턴 3가지**

### 1. **Try-Except 패턴** (안정성)
```python
# 모든 핵심 함수는 이 패턴 사용
try:
    result = risky_operation()
    if self._is_result_valid(result):
        return result
except Exception as e:
    logger.warning(f"Operation failed: {e}")
    return fallback_result()  # 항상 결과 보장
```

### 2. **설정 기반 패턴** (유연성)
```python
# 하드코딩 대신 설정 파일 사용
weights = self.config['risk_scoring']['weights']
thresholds = self.config['changepoint_detection']['thresholds']

# 설정 변경만으로 시스템 동작 조정 가능
```

### 3. **로깅 패턴** (투명성)
```python
# 모든 중요한 결정에 로그 남김
logger.info(f"✅ {model_type} 모델 선택: 신뢰도 {confidence:.1%}")
logger.warning(f"⚠️ 데이터 부족: {region_id}, fallback to regional")
logger.error(f"❌ 예측 실패: {error_msg}")

# → 나중에 왜 그런 결정을 했는지 추적 가능
```

---

## 🚀 **실제로 해볼 수 있는 코드 실험**

### 실험 1: 위험도 계산 로직 확인
```python
# src/risk_scoring/risk_calculator.py 의 _score_revenue_change 함수 수정
def _score_revenue_change(self, revenue_change):
    print(f"🔍 매출 변화율 입력: {revenue_change}%")
    
    if revenue_change >= 20:
        score = 10
        print(f"→ 20% 이상 증가: {score}점 (낮은 위험)")
    elif revenue_change >= -10:
        score = 50  
        print(f"→ -10% ~ +20% 범위: {score}점 (보통 위험)")
    else:
        score = 90
        print(f"→ 10% 이상 감소: {score}점 (높은 위험)")
    
    return score

# 테스트: 다양한 매출 변화율로 실험해보기
```

### 실험 2: 모델 선택 로직 확인  
```python
# model_orchestrator.py 에서 디버깅 출력 추가
def predict(self, business_data):
    region_id = business_data.get('region_id')
    print(f"🎯 예측 요청: {region_id}")
    
    # Local 시도
    if self._has_local_model(region_id):
        print("✅ Local 모델 있음 → 시도")
    else:
        print("❌ Local 모델 없음 → Regional로 전환")
        
    # 실제 선택 결과 확인해보기
```

---

**🎉 결론: 복잡해 보이는 시스템도 결국 단순한 로직들의 조합입니다!**

1. **데이터 입력** → 숫자들을 의미있는 특성으로 변환
2. **모델 선택** → 가장 적합한 AI 모델 자동 선택  
3. **위험도 계산** → 5개 요소를 가중평균으로 점수화
4. **대출 승인** → 위험도에 따라 한도 자동 계산

**각 단계의 코드가 이해되시면, 전체 시스템의 동작 원리가 명확해집니다!** 🚀